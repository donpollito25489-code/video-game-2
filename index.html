<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Fortnite ‚Äì Grid Build Edition</title>
<style>
body { margin:0; overflow:hidden; background:black; }
#ui {
  position:fixed; top:10px; left:10px;
  font-family:Arial; color:white; z-index:10;
  background:rgba(0,0,0,0.5); padding:10px;
}
#miniMap {
  position:fixed; top:10px; right:10px;
  width:150px; height:150px;
  background:#111; border:2px solid white;
  z-index:10;
}
</style>
</head>
<body>

<div id="ui">
‚ù§Ô∏è <span id="health">100</span><br>
üõ°Ô∏è <span id="shield">50</span><br>
ü™µ <span id="wood">100</span><br>
üî´ <span id="weapon">AR</span>
</div>
<canvas id="miniMap"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>

/* ---------------- SCENE ---------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ---------------- LIGHT ---------------- */
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const sun = new THREE.DirectionalLight(0xffffff,0.8);
sun.position.set(50,100,50);
scene.add(sun);

/* ---------------- TERRAIN ---------------- */
const MAP_SIZE = 200;
const terrain = new THREE.Mesh(
  new THREE.PlaneGeometry(MAP_SIZE,MAP_SIZE),
  new THREE.MeshStandardMaterial({color:0x2e8b57})
);
terrain.rotation.x = -Math.PI/2;
scene.add(terrain);

/* ---------------- GRID ---------------- */
const GRID = 4;
const snap = v => Math.round(v/GRID)*GRID;

/* ---------------- PLAYER ---------------- */
const player = new THREE.Group();
const body = new THREE.Mesh(
  new THREE.CapsuleGeometry(0.5,1.2),
  new THREE.MeshStandardMaterial({color:0x0000ff})
);
player.add(body);
player.position.set(0,1,0);
scene.add(player);

let health=100, shield=50, wood=100;
let yaw=0, pitch=0;
let vy=0, onGround=true;

/* ---------------- CAMERA ---------------- */
document.body.addEventListener("click",()=>document.body.requestPointerLock());
document.addEventListener("mousemove",e=>{
  if(document.pointerLockElement!==document.body)return;
  yaw -= e.movementX*0.002;
  pitch -= e.movementY*0.002;
  yaw = Math.max(-Math.PI/2, Math.min(Math.PI/2, yaw)); // 180¬∞
  pitch = Math.max(-1.1, Math.min(1.1, pitch));
});

/* ---------------- INPUT ---------------- */
const keys={};
addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

/* ---------------- BUILDING ---------------- */
let buildMode="wall";
const raycaster=new THREE.Raycaster();
let preview;

function makePreview(){
  if(preview) scene.remove(preview);
  const geo = buildMode==="wall"
    ? new THREE.BoxGeometry(4,4,0.3)
    : new THREE.BoxGeometry(4,0.3,4);
  preview=new THREE.Mesh(
    geo,
    new THREE.MeshStandardMaterial({color:0x00ff00,opacity:0.4,transparent:true})
  );
  scene.add(preview);
}
makePreview();

addEventListener("keydown",e=>{
  if(e.key==="q"){buildMode="wall";makePreview();}
  if(e.key==="e"){buildMode="floor";makePreview();}
});

/* ---------------- BULLETS ---------------- */
const bullets=[];

/* ---------------- AI ---------------- */
const enemies=[];
function makeAI(x,z){
  const g=new THREE.Group();
  g.add(new THREE.Mesh(
    new THREE.CapsuleGeometry(0.5,1.2),
    new THREE.MeshStandardMaterial({color:0xff0000})
  ));
  g.position.set(x,1,z);
  g.userData={health:50};
  scene.add(g);
  enemies.push(g);
}
for(let i=0;i<12;i++){
  makeAI(Math.random()*MAP_SIZE-MAP_SIZE/2,Math.random()*MAP_SIZE-MAP_SIZE/2);
}

/* ---------------- TILTED BUILDINGS ---------------- */
function tiltedTower(x,z){
  const mat=new THREE.MeshStandardMaterial({color:0xaaaaaa});
  for(let y=2;y<=6;y+=4){
    const floor=new THREE.Mesh(new THREE.BoxGeometry(8,4,8),mat);
    floor.position.set(x,y,z);
    scene.add(floor);
  }
  const roof=new THREE.Mesh(new THREE.BoxGeometry(8,0.5,8),mat);
  roof.position.set(x,8.5,z);
  scene.add(roof);
}
tiltedTower(20,20);
tiltedTower(-30,-10);

/* ---------------- UPDATE ---------------- */
function update(){
  const speed=0.2;
  const fwd=new THREE.Vector3(Math.sin(yaw),0,-Math.cos(yaw));
  const right=new THREE.Vector3(Math.cos(yaw),0,Math.sin(yaw));

  if(keys.w) player.position.add(fwd.clone().multiplyScalar(speed));
  if(keys.s) player.position.add(fwd.clone().multiplyScalar(-speed));
  if(keys.a) player.position.add(right.clone().multiplyScalar(-speed));
  if(keys.d) player.position.add(right.clone().multiplyScalar(speed));

  if(keys[" "]&&onGround){vy=0.35;onGround=false;}
  vy-=0.02; player.position.y+=vy;
  if(player.position.y<1){player.position.y=1;vy=0;onGround=true;}

  camera.position.copy(player.position)
    .add(new THREE.Vector3(Math.sin(yaw)*6,4,-Math.cos(yaw)*6));
  camera.lookAt(player.position.x,player.position.y+1.5,player.position.z);

  raycaster.setFromCamera(new THREE.Vector2(0,0),camera);
  const hit=raycaster.intersectObject(terrain)[0];
  if(hit){
    preview.position.set(
      snap(hit.point.x),
      buildMode==="wall"?2:0.15,
      snap(hit.point.z)
    );
  }

  enemies.forEach(e=>{
    const targets=[player,...enemies.filter(o=>o!==e)];
    let t=targets[Math.floor(Math.random()*targets.length)];
    const d=t.position.clone().sub(e.position).normalize();
    e.position.add(d.multiplyScalar(0.03));
  });

  document.getElementById("health").textContent=health;
  document.getElementById("shield").textContent=shield;
  document.getElementById("wood").textContent=wood;
}

function animate(){
  requestAnimationFrame(animate);
  update();
  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

</script>
</body>
</html>
